#


"""
    The script with take a csv file generated by tabula. For the process
    one single player must be process as a time from the "Abierto Argentino 2016.pdf"
    At this effect select on the player´s section tree areas: One line areawith the
    team´s name; one line area with the player's name and handicap, and the body area including the
    information on the player's horses. Before and after processing the tabula program verify the extraction
    result (preview) of the tabula pdf  and preferably choose the option "stream" for
    the process.
    The script first normalizes the information adding a field to caunt por the AACCPA status of the
    horse, selects the elegible horses and allows the user to decide about it (or automatically makes the
    choice). The normalized file is placed in a list to be process by the parser, and its result are saved
    in the above mentioned dict.
    Previous step in tabula:
        - From the pdf file with the tournement data:
            - Choose three sections related to one player as described above.
            - Check that the data was properly captured. Eventually reload using the stream option
            - Export and save de file as follows: "Tournament year team Player.csv"
    Usage:
        "tournament"- required: name of the competition
        "year"      - required: tournament´s year
        "dirname"   - required: path to the files for IO.
        "filename"  - required: csv from tabula por one player to parse.
        "outfile"   - optional: pic output file. Defaults to "[tournament year].pic"
        "parser"    - optional: parser to be use
        "load"      - optional: Loads the saved pic file before parsing
        "auto"      - optional: Chooses the AACCPA status based on the fields
                                birthday, stallion and mare as requiered for it.
        "compress"  - optional: Saves the pickle file "pic" in compress format.
    To Do:
        Client side:    Develop a method for pulling a player aut of the dictionary as
                        to eliminate/re-load it. - From main check for load.
        Server side:    Develop a server/client approach taking the generated dictiona
                        and stores de result in a SQlite database. Start development with
                        client and server on the same network
        Investigate:    Placing the Server on the cloud
                        Accessing the server through the internet by direct connection.
                        Accessing the server through the web. Placing the server on the web.








"""

import sys
import os
import argparse
from datetime import datetime
import pickle
import gzip
import webbrowser
from collections import namedtuple

if "pyparsing" not in sys.modules:
    sys.path.append("c:/python364/lib/site-packages")
    sys.path.append("C:/users/erick/python study/Networking")

try:
    from pyparsing import (alphas, alphanums, nums, Suppress, OneOrMore,
                           ZeroOrMore, Literal, alphas8bit, Word,
                           CharsNotIn, Group, Combine, Optional,
                           ParseException, ParseSyntaxException,
                           removeQuotes, LineEnd, oneOf, Or,
                           quotedString, col, empty, ParserElement,
                           Keyword, restOfLine, Linestart)
except ImportError as err:
    sys.path.append("c:/python364/lib/site-packages")
import socket
import struct
import Console
from subprocess import run, Popen
from sqlite3 import IntegrityError

"""
    LINES          ::= HEADER_LINE * PLAYER_LINE + (LINE| LINE + LINES)
    HEADER_LINE    ::= ?(a-zA-z]
    LINE           ::= HORSE COLOR BIRTH? FATHER? MATHER? GRANDMOTHER? OWNER BREEDER
    HORSE           ::= [a-zA-Z]+ 
                           
  
  
    
"""

def pyparsing_parse(horses, dict_tournament, tournament, tournament_year,spc_check):
    """
    Takes a normalized list of team, player, horse1.....horsen
    parses the lines and return a dict with the Team name, player name and
    handicap, and for the horses name, coat, birthdate/year, stallion,
    ,mare, grandmare, owner, beeder, and AACCPA status as a boolean.
    The return dict base key is the team with a dict as value with key: horse
    and a namedtuple as values.
    :param horses:
    :return: dict_team
    """

    def check_date(tokens):
        try:
            datetime.strptime(tokens.date,"%d/%m/%Y")
            tokens = tokens.year + '/' + tokens.month + '/' + tokens.day
        except ValueError as err:
            tokens = ''
        return tokens

    def check_empty(tokens):
        if len(tokens) == 0:
            tokens = None
            return

    def check_cpa(tokens):
        if not isinstance(tokens[0], str):
            tokens = "False"
        return tokens

    def check_HCP(tokens):
        if 0 < int(tokens[0]) <= 10:
            return
        else:
            raise ValueError("Handicap ranges from 0 tp 10")

    Equs = namedtuple("Equs", "birth_date birth_year sex_id coat "
                                  "stallion mare grandmare "
                                  "owner breeder aaccpa spc rp sba")
    
    sexes = {"M":1, "C": 2,"H": 3}
    startfile = (Suppress(Literal('""')) ^ Suppress(Literal("\ufeff")) ^
                 Suppress(Literal('\ufeff""')) ^ empty)
    startline = Suppress(Literal("\ufeff"))
    comma = Suppress(",")
    signs = "&.()-"
    team = (startfile + Optional(ZeroOrMore(comma)) +
            OneOrMore(CharsNotIn(",\n\t/\\")))("team").setParseAction(lambda tokens: " ".join(tokens))
    team.addParseAction(lambda tokens: tokens[0].title())
    handicap = (Suppress(OneOrMore(comma) + Keyword("HCP")) + Word(nums, max=2))("handicap").setParseAction(
        check_HCP)
    player = (Suppress(Word(nums, exact=1) + ".") +
              OneOrMore(Word(alphanums + alphas8bit + signs)))("player")
    player.setParseAction(lambda tokens: " ".join(tokens))
    player.addParseAction(lambda tokens: tokens[0].title())
    player_name = player + handicap
    name = (Word(alphanums) + Optional(Word(alphanums)) +
            Optional(Literal("(")) + Optional(OneOrMore(Word(alphanums))) +
            Optional(Literal("-")) + Optional(Literal(")")) +
            Optional(Word(alphas)) + Optional(Word(nums)) +
            Optional(Literal("(")) + Optional(OneOrMore(Word(alphanums))) +
            Optional(Literal(")")))("name").setParseAction(
            lambda tokens: " ".join(tokens))
    name.addParseAction(lambda tokens: tokens[0].title())
    coat = (oneOf("a z zc t A Z ZC zn ZN T") ^
            empty)("coat").setParseAction(lambda tokens: tokens[0].upper())
    coat.addParseAction(check_empty)
    day = (Word(nums, exact=2) ^ empty)("day").setParseAction(check_empty)
    month = (Word(nums, exact=2) ^ empty)("month").setParseAction(check_empty)
    year = (Word(nums, exact=4) ^ empty)("year").setParseAction(check_empty)
    date = Optional(Combine(day + "/" + month + "/" + year))("date").setParseAction(
        check_date)
    birthday = ((date ^ year) ^ empty)("birthday").setParseAction(check_empty)
    stallion = (OneOrMore(Word(alphanums + alphas8bit)) ^
                empty)("stallion").setParseAction(lambda tokens: " ".join(tokens))
    stallion.addParseAction(lambda tokens: tokens[0].title())
    stallion.addParseAction(check_empty)
    mare = (OneOrMore(Word(alphanums + alphas8bit + signs)) ^
            empty)("mare").setParseAction(lambda tokens: " ".join(tokens))
    mare.addParseAction(lambda tokens: tokens[0].title())
    mare.addParseAction(check_empty)
    grandmare =(OneOrMore(Word(alphanums + alphas8bit)) ^
                empty)("grandmare").setParseAction(lambda tokens: " ".join(tokens))
    grandmare.addParseAction(lambda tokens: tokens[0].title())
    grandmare.addParseAction(check_empty)
    person = OneOrMore(Word(alphanums + alphas8bit + signs)).setParseAction(lambda tokens: " ".join(tokens))
    society = quotedString.setParseAction(removeQuotes)
    owner = (person ^ society ^ empty)("owner").setParseAction(lambda tokens: tokens[0].title())
    owner.addParseAction(check_empty)
    breeder = (OneOrMore(Word(alphanums + alphas8bit + signs)) ^
               empty)("breeder").setParseAction(lambda tokens: " ".join(tokens))
    breeder.addParseAction(lambda tokens: tokens[0].title())
    breeder.addParseAction(check_empty)
    cpa = (Word(alphas) ^ empty)("cpa").addParseAction(check_cpa)
    parser = (name + comma + coat + comma +
              birthday + comma + stallion + comma + mare + comma +
              grandmare + comma + owner + comma +
              breeder + comma + Optional(cpa))
    dict_player = {}

    for lineno, line in enumerate(horses,start=1):
        try:
            if lineno == 1:
                polo_team = team.parseString(line)[0]
                dict_tournament[tournament][tournament_year][polo_team] = {}
                continue
            elif lineno == 2:
                player = player_name.parseString(line)
                dict_player[player.player] = {}
                dict_player[player.player]['Handicap'] = player.handicap[0]
                continue
            result = parser.parseString(line, parseAll=False)

            equine = (result.birthday, result.coat,
                            result.stallion, result.mare, result.grandmare,
                            result.owner, result.breeder, result.cpa)
            sex_id, rp, sba, cpa , spc = get_sex(result.name, equine, sexes, spc_check)
            #+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
            spc = 1 if "S.P.C." in result.breeder else 0
            if len(result.birthday) == 0:
                birth_date = birth_year = None
            elif len(result.birthday) == 10:
                birth_date = result.birthday
                birth_year = result.birthday[:4]
            elif len(result.birthday) == 4:
                birth_date = None
                birth_year = result.birthday
            if len(result.breeder) == 0:
                result.breeder = None
            elif "S.P.C." in result.breeder:
                result.breeder = None
            cpa = 1 if result.cpa == "True" else 0
            equs = (birth_date,birth_year,sex_id,result.coat,
                           result.stallion, result.mare, result.grandmare,
                           result.owner, result.breeder, cpa,
                           spc, rp, sba)
            #+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
            dict_player[player.player][result.name] = equs
        except (ParseSyntaxException, ParseException) as err:
            print("Syntax error:\n {0.line} \n{1}^".format( err,
                                                           " " * (err.column - 1)))
            continue
    dict_tournament[tournament][tournament_year][polo_team] = dict_player
    return dict_tournament

def normalize(fh, auto=False):
    """
        It takes de csv file as input and normalize de
        field and allows for setting the cpa field
        -caballo polo argentino- boolean variabñe.
        It use the "commas" to identify the missing end
        fields. It parse the lines as to identify the
        horses with birth date/year, stallion and mare, potencially
        in the AACCPA register. Allows the user to choose.

        :param fh:
        :return horse:
    """
    signs = "&.()-"
    comma = Suppress(Literal(","))
    name = (Word(alphas) + Optional(Word(alphanums)) +
            Optional(Literal("(")) + Optional(OneOrMore(Word(alphanums))) +
            Optional(Literal("-")) + Optional(Literal(")")) +
            Optional(Word(alphas)) + Optional(Word(nums)))("name").setParseAction(
            lambda tokens: " ".join(tokens))
    name.addParseAction(lambda tokens: tokens[0].title())
    coat = (oneOf("a z zc t A Z ZC zn ZN T") ^
            empty)("coat").setParseAction(lambda tokens: tokens[0].upper())
    day = Word(nums, exact=2)("day")
    month = Word(nums, exact=2)("month")
    year = Word(nums, exact=4)("year")
    date = Optional(Combine(day + "/" + month + "/" + year))("date")
    stallion = (OneOrMore(Word(alphanums + alphas8bit)))("stallion").setParseAction(lambda tokens: " ".join(tokens))
    stallion.addParseAction(lambda tokens: tokens[0].title())
    mare = (OneOrMore(Word(alphanums + alphas8bit + signs)))("mare").setParseAction(lambda tokens: " ".join(tokens))
    mare.addParseAction(lambda tokens: tokens[0].title())
    match =  (name + comma + coat + comma +
              date + comma + stallion + comma + mare)
    horses = []
    for lineno, line in enumerate(fh, start=1):
        if lineno > 2 :
            ans = "n"
            if line.count(",") >= 7:
                line = line[:line.index("\n")] + ",\n"
            result = match.searchString(line)
            if len(result) > 0:
                if not auto:
                    print("The horse {0} may be a AACCPA registered horse". format(line))
                    ans = input("Do you want to accept it?('Y/N')")
                else:
                    ans = "y"
            line = line[:line.rindex(",")] +",True\n" if ans in ("Yyes") else line[:line.rindex("\n")] + "False,\n"
        horses.append(line)
    return horses

#+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
def get_sex(horse, tup,sexes, spc_check):
    """
    Takes the horses name and data tuple and allows the user to input the horses ses. If there is
    enough information to check for the validity of AACCPA registration, opens the web site to allow for
    checking the sex, RP and SBA of the horse.
    If the horse it is not an AACCPA horse, and S.P.C. shows at the breeder's field, the registratios at the
    Stud Book could be checked id the SPC option is selected.
    http://190.210.180.194/Webcriadores/Pedigree.aspx?prod=&Especie=2&Sexo=0&RecargarFiltros=SI&Raza=74
    http://190.210.180.194/Webcriadores/Pedigree.aspx?prod=&Especie=2&Sexo=0&RecargarFiltros=SI&Raza=74
    :param horse:
    :param tup:
    :return:
    """
    sex_data = {1: "Macho", 2: "Macho Castrado", 3: "Hembra"}
    aaccpa = eval(tup[7])
    sba = None
    rp = None
    spc = False
    action = "g"

    print("\nHorse´s information to verify:\n"
              "\tHorse name: {}\n"
              "\tBirth data: {}\n"
              "\tCoat: {}\n"
              "\tFather: {}\n"
              "\tMother: {}\n"
              "\tGrandmother: {}\n"
              "\tOwner: {}\n"
              "\tBreeder: {}\n"
              "\tAACCPA: {}".format(horse,*tup))

    while True:

        if aaccpa:
            valid = "gvGV"
            action = Console.get_menu_choice("Enter your (g)uess for the horse's sex or \n"
                                         "(v)alidate the information with the SRA database "
                                         "getting also the horse's RP and  SBA",
                                         valid, "v", True)
        if action == "g" or not aaccpa:
            if spc_check:
                if "S.P.C." not in tup[6]:
                    ans = Console.get_menu_choice("Want to check the SBA's thoroughbred database? (Y/N)", "(YyNn)","n")
                else:
                    ans =  "y"
                if ans == "y":
                    url = "http://www.studbook.com.ar/"
                    print("""At the web page choose the option 'Volumen en linea'
                    and at the new page that opens choose 'indice general'.
                    You'll be able to check on the main page or get details by 
                    clicking on the horse's name.
                    Warning: Many horses showwn as S.P.C. are either imported and/or not
                    registered at the SBA and in many cases the main name use is the polo's name instead
                    of the thoroughbred name""")
                    input("Press any key to continue")
                    web_page = webbrowser.open_new_tab(url)
            valid = "mchMHC"
            sex = Console.get_menu_choice("""Enter the horse's sex as stated at the SBA registry
             or make your best guess if not found:
                                        Name: '{}' born on: '{}'
                                        coat: '{}' by: '{}' on '{}' mare grandmare: '{}
                                        own by: '{}' bread by: '{}'
                                        (m)acho; (g) castrado; (h)embra""".format(horse,*tup),
                                          valid,"h",True)
            sex_id = sexes[sex.upper()]
            rp = sba = None
            spc = Console.get_menu_choice("The horse appears to be at the SBA database: (T)tue or it's not showing: "
                                          "(F)alse","TFtf","T").lower()
            spc = True if spc == "y" else False
        elif action == "v":
            url = """http://190.210.180.194/Webcriadores/
Pedigree.aspx?prod=&Especie=2&Sexo=0&RecargarFiltros=SI&Raza=74"""
            print()
            print("At the web page choose the option 'Nombre' and make yor sex guess - either 'Macho' or 'Hembra' \n"
                "if there is a result from the query, verify that the date of birth, coat, and owner coincides \n"
                "-owner may have changed- , click on  'info' to check the breeder and details.\n ")
            input("Press any key to continue")

            web_page = webbrowser.open_new_tab(url)
            print("\n")
            valid = "MHmh"
            sex_id = sexes[Console.get_menu_choice("Enter the sex: (m)acho; (h)embra", valid,'h', True).upper()]
            while True:
                sba = input("Enter the SBA -'nro Inscrip.'- from de SRA database\n\tEnter for none")
                rp = input("Enter the RP from the SRA database\n\tEnter for none")
                if len(sba) == 0: sba = None
                if len(rp) == 0: rp = None
                if sba is None and rp is None:
                    ans = Console.get_menu_choice("Please confirm that the horse is not registered in the AACCPA (Y/N)","YyNn","y")
                    if ans in "YyYesyes":
                        aaccpa = False
                        break
                else:
                    break
        message = "The horse '{}'s sex has been set as: {} with RP: {} and SBA: {}. Confirm the data? (Y/N)"\
            .format(horse, sex_data[sex_id], rp, sba) if aaccpa else "The horse {}'s sex has been set has {} and it's not " \
                                                              "registered at the AACCPA horse registry..\n" \
                                                              " Confirm the data? (Yes) (N)".format(horse, sex_data[sex_id])
        ans = Console.get_menu_choice(message,"YNyn","y")
        if ans in ("YyYesyes"):
            break

    return (sex_id, rp, sba, aaccpa, spc)


#-----------------------------------------------------------------------------

def import_dict(filename, dict_team, loaded_set):
    fh = None
    GZIP_MAGIC = b"\x1F\xBB"
    try:
        fh = open(filename, "rb")
        magic = fh.read(len(GZIP_MAGIC))
        if magic == GZIP_MAGIC:
            fh.close()
            fh = gzip.open(filename, "rb")
        else:
            fh.seek(0)
        team, loaded = pickle.load(fh)
        dict_team.update(team)
        loaded_set.update(loaded)
        return True
    except (EnvironmentError, pickle.PicklingError) as err:
        print("{0}: importing error {1}".format(os.path.basename(filename), err))
        return False
    finally:
        if fh is not None:
            fh.close()
    

            



def export_dict(dict_team, filename, loaded_set, compress=False):
    fh = None
    if os.path.lexists(filename):
        ans = input("You are about to overwrite the file {0}! continue? (Y/N)".format(filename))
        if ans not in "Yyes":
            return
    try:
        fh = open(filename, "wb") if not compress else gzip.open(filename, "wb")
        pickle.dump((dict_team,loaded_set), fh,pickle.HIGHEST_PROTOCOL )
        print("File: {0} has been successfully saved".format(os.path.basename(filename)))
        return True
    except (EnvironmentError, pickle.PicklingError)  as err:
        print("{0}=> exporting error {1}".format(os.path.basename(filename),err))
        return False
    finally:
        if fh is not None:
            fh.close()


def ply_parse(horses,dict_tournament, tournament, tournament_year):
    print("Process on the works")

def regex_parse(horses,dict_tournament, tournament, tournament_year):
    print("work in progress")


def handle_request(address, *items, wait_for_reply=True):
    SizeStruct = struct.Struct("!I")
    data = pickle.dumps(items[0], 4)

    try:
        with SocketManager(tuple(address)) as sock:
            sock.sendall(SizeStruct.pack(len(data)))
            sock.sendall(data)
            if not wait_for_reply:
                return
            size_data = sock.recv(SizeStruct.size)
            size = SizeStruct.unpack(size_data)[0]
            result = bytearray()
            while True:
                data = sock.recv(4000)
                if not data:
                    break
                result.extend(data)
                if len(result) >= size:
                    break
        return pickle.loads(result)
    except socket.error as err:
        print("{0}: Is the server running?".format(err))
        sys.exit(1)

            

            
def parse_options():
    parser = argparse.ArgumentParser()
    parser.add_argument("tournament", help="name of the tournament")
    parser.add_argument("year", help="tournament´s year")
    parser.add_argument("dirname",help="Input the path to"
                                       "the input and output files")
    parser.add_argument("-f", "--file", dest="filename",
                        help="Input the cvs tabula generated file to parse")
    parser.add_argument("-o","--outfile", dest="outfile",
                        help="Output file to save a picked dictionary")
    parser.add_argument("-p", "--parser", dest="parser",
                        choices=["ply", "pyparsing", "regex"], default="pyparsing",
                        help="parser to apply")
    parser.add_argument("-l", "--load", dest="load", action="store_true",
                        default=False, help="Loads a previous existing pic file data")
    parser.add_argument("-a", "--auto", dest="auto", action="store_true",
                        default=False, help="Process the AACCPA status "
                                            "automatically")
    parser.add_argument("-c", "--compress", dest="compress",
                        default=False, action="store_true",
                        help="saves de dictionary as a (compressed) pickle file")
    parser.add_argument("-i", "--ipaddress", dest="ip",default="127.0.0.0",
                        help="Server IP address")
    parser.add_argument("-t", "--port", dest="port",type=int, default= 9000,
                        help="port in use for the system")
    parser.add_argument("-s", "--spc", dest="spc", action="store_true",
                        default=False, help="Allows to validate the horse's name against"
                                            "the Argentine Stood Book")

    args = parser.parse_args()
    if args.filename is not None:
        args.outfile = args.filename[:args.filename.find(".")] + ".pic"
        assert args.filename.endswith(".csv"), "Input file must be a csv file"
    assert args.year.isnumeric() and len(args.year) == 4, "Year must be a number in de form of '####'"
    return args


def main():

    args = parse_options()
    address = args.ip, args.port


    # **********************
    call = dict(t=team_load, e=tournament_save, d=check_db,
                s=stop_server, q=quit, a=load_pdf, l=check_dir, b=database_query)
    dict_tournament = None
    while True:
        if dict_tournament is None:
            if args.filename is not None:
                if not os.path.isfile(os.path.join(args.dirname, args.filename)):
                    print("\nThe file: '{}' has not been processed so far. \n"
                          "Load the pdf file into 'Tabula' and extract the information.\n"
                          "Once done identify the file in the directory.".format(args.filename))
                    menu = ("T{a}bula (S)top Server (Q)uit")
                    valid = "aAsSqQ"
                else:
                    db_check = call['d'](args, address)
                    if db_check[0]:
                        valid = frozenset("tTeEsSqQdD")
                        menu = ("(T)eam Load (D)atabase Query (S)top Server (Q)uit")
                    else:
                        valid = frozenset("tTsSqQ")
                        menu = ("(T)eam Load (S)top Server (Q)uit")
            else:
                db_check = call["d"](args, address)
                if db_check[0]:
                    print("\nYou may: open 'Tabula' to save a new player´s csv file; \n"
                        "choose one of the saved files at the directory: '{}';\n"
                        "or query the database".format(args.dirname))
                    menu = "[L)ook Directory T(a)bula Data(b)ase Query (S)top Server (Q)uit"
                    valid = "LlAaSsQqbB"
                else:
                    print("\nYou may: open 'Tabula' to save a new player´s csv file; \n"
                        "choose one of the saved files at the directory: '{}'.".format(args.dirname))
                    menu = "[L)ook Directory T(a)bula (S)top Server (Q)uit"
                    valid = "LlAaSsQq"
        else:
            db_check = call["d"](args, address)
            if not db_check[0]:
                valid = frozenset("tTeEsSqQLlaA")
                menu = ("(L)ook Directory T(a)bula T(e)am Save (S)top Server (Q)uit")
            else:
                valid = frozenset("eEsSqQlLaAbB")
                menu = ("(L)ook Directory T(a)bula T(e)am Save Data(b)ase Query"
                "(S)top Server Q(u)it")
        print()
        action = Console.get_menu_choice(menu, valid, "q", True)
        call_response = call[action](dict_tournament, args, address)
        if isinstance(call_response, dict):
            dict_tournament = call_response
        if action =='l':
            args.filename = call_response
            #args.outfile = call_response[1]
        elif action == "d":
            pass

    #  ************************************

def check_dir(*items):
    return_name = None
    out_name = None
    file_lst = [file for file in os.listdir(items[1].dirname) if file.endswith(".csv")]
    for num, filename in enumerate(file_lst):
        print(num, filename)
    valid = [str(num) for num in range(len(file_lst))]
    valid.append("")
    action = Console.get_menu_choice("Input the file number or 'Enter' for exiting",valid,None)
    if action.isnumeric():
        return_name = file_lst[int(action)]
        out_name = return_name[:return_name.index(".csv")] + ".pic"
    return return_name


def stop_server(*ignore):
    handle_request("SHUTDOWN", wait_for_reply=False)
    sys.exit()


def quit(*ignore):
    sys.exit()


def team_load(*items):
    parsing_option = dict(pyparsing=pyparsing_parse, ply=ply_parse, regex=regex_parse)
    dict_tournament, args, address = items
    file = os.path.join(args.dirname, args.filename)

    if args.load:
        dict_tournament = {}
        loaded_set = set()
        if not args.outfile:
            args.outfile = file[:file.find(".csv")] + ".pic"
        if os.path.isfile(args.outfile):
            import_dict(args.outfile, dict_tournament, loaded_set)
        if loaded_set:

            if args.filename in list(loaded_set)[0]:
                message = "'{}' it's already loaded in system's dictionary and pickle file!\n" \
                          "Do yo want to reload it? (y/n)".format(args.filename)
                ans = Console.get_menu_choice(message,"YyNn","n")
                if ans == "n":
                    result = dict_tournament
                    loaded_set = (file,)
                    return result
                else:
                    try:
                        os.remove(out_file)
                    except OSError as err:
                        print("File {} was not deleted because {}".format(args.outfile, err))
    dict_tournament = {args.tournament:{args.year:{}}}
    loaded_set = {file,}

    with open(file, "r", encoding="utf8") as fh:
        horses = normalize(fh, args.auto)
        result = parsing_option[args.parser](horses, dict_tournament, args.tournament, args.year, args.spc)

    for key, tournament in result.items():
         print(key, end=' ')
         for key, year in tournament.items():
             print(key,end="\n")
             for key, team in year.items():
                print(key,end=" ")
                for key, player in team.items():
                    print(key)
                    for key, horse in player.items():
                        print(key, horse, end="\n")
    ans = input("Do you want to save de results? (Y/N) ")
    if ans in "yYes":
        export_dict(result, args.outfile, loaded_set, args.compress)
    return result

def tournament_save(*items):
    result, args, address = items
    if result is None:
        print("You must load the information to save fist")
        return
    ok, data = handle_request(address, ["LOAD_TOURNAMENT",result])
    if not ok:
        print("Transfer failed")
        return
    print(ok[1])

def check_db(*items):
    args, address = items
    ok, data = handle_request(address, ["CHECK_DB"])
    print(ok)
    return ok

def load_pdf(*items):

    filename = "'Tournamet' 'year' 'Team' 'Player'.csv" if items[1].filename is None else items[1].filename


    ans = input("""In 'Tabula' select a single player to process at a time
    from the 'Tournament year'.pdf file.
    Select on the player´s section three areas:
    \tOne line area with the team´s name;
    \tone block area with the player's name and handicap row; plus the
    \tblock area including all of the player´s horses rows.
    Before and after processing the tabula program verify the extraction
    result (preview) data with the pdf file.
    Preferably choose the option "stream" option for proccesing.
    Save the results as a csv file named as: '{}'.
    Proceed? (Y/N)""".format(filename))

    out_file = os.path.join(items[1].dirname, items[1].filename) if \
        items[1].filename is not None else \
        os.path.join(items[1].dirname, "'tournament' 'year' 'Team' 'Player'.csv")
    if ans in ("Yy"):
        try:
            proc = Popen("tabula.exe")
            if ans not in ("Yy"):
                return False
            if items[1].filename is None:
                filename = input("Enter the file name to be saved")
                if filename != "":
                    items[1].filename = filename + ".csv"
                else:
                    print("No file has been saved")
                    return False

            if os.path.isfile(items[1].filename):
                return True

        except FileNotFoundError as err:
            print("Tabula is not available. Error {}{".format(err))
            return False

def database_query(*items):

    def check_aaccpa(tup):
        url = """http://190.210.180.194/Webcriadores/
Pedigree.aspx?prod=&Especie=2&Sexo=0&RecargarFiltros=SI&Raza=74"""
        #Pedigree.aspx?prod=&Especie=2&Sexo=0&RecargarFiltros=SI&Raza=74"""
        print()
        print("At the web page choose the options:"
              "\n\t\tEspecie: 'Equinos'"
              "\n\t\tRaza : '(274) Polo Argentino"
              "\n\t\tSexo: 'Macho or Hembra'"
              "\n\t\tCodigo: 'Nombre' or 'SBA'"
              "\n\t\tEnter either the horse name or the horse's SBA number"
              "\nBegin by identifying the foal data and that the parent data coincides. "
              "\n If in doubt query the parent horse. Verify that the date of birth, coat, coincides \n"
              "-owner may have changed- , click on  'info' to check the breeder and details.\n ")
        input("Press any key to continue")

        web_page = webbrowser.open_new_tab(url)
        print("\n")
        ans = Console.get_menu_choice("Are you satisfied with the information (Y)es (N)o", "YyNn", "y", True)
        if ans == "n":
            ans = Console.get_menu_choice("Do you need to modify the horse's name? (Y)es, (N)o", "YyNn", "n", True)
            if ans == "y":
                horse_name = imput("Enter the modified horse name")
                return True, horse_name
        result = True if ans == "y" else False
        return result, "Ok"

    def update_ancestor(cat,coats, *tup):
        print(tup)
        if cat == "m":
            message = "\nThe mare '{0[0]}' foaled  the:\n" \
                      "\t{0[11]} {0[3]} '{0[1]}' sba '{0[9]}' on {0[2]} by  '{0[4]}'."\
                                    "\nDo you want to: " \
                                    "\n\tCheck the (A)ACCPA; or " \
                                    "\n\t(C)ancel ".format(*tup)
        elif cat == "s":
            message = "\nThe stallion '{0[0]}' sired the:\n" \
                      "\t{0[11]} {0[3]} '{0[1]}' SBA: {0[9]} on {0[2]} on  '{0[4]}'."\
                                    "\nDo you want to: " \
                                    "\n\tCheck the (A)ACCPA; or " \
                                    "\n\t(C)ancel ".format(*tup)
        elif cat == "g":
            message = "\nThe Grandmare '{0[0]}' gandmaded  the:\n" \
                      "\t{0[12]} {0[3]} '{0[1]}' on {0[2]} sba {0[9]} by  '{0[4]} on {0[10]}' SBA {0[11]}."\
                                    "\nDo you want to: " \
                                    "\n\tCheck the (A)ACCPA; or " \
                                    "\n\t(C)ancel ".format(*tup)
        act = Console.get_menu_choice(message, "CcsSaA", "a", True)
        if act == "c":
            return None, "Canceled"
        elif act == "a":
            res = check_aaccpa(tup)
            if res[0]:
                while True:
                    horse_name = tup[0][0] if res[1] == "Ok" else res[1]
                    sba = input("Enter the SBA: ")
                    rp = input("Enter the RP:")
                    rp = rp if rp != "''" else None
                    while True:
                        birth = input("Enter the birth date as 'yyyy/mm/dd':")
                        try:
                            datetime.strptime(birth,"%Y/%m/%d")
                            break
                        except ValueError as err:
                            if birth == '':
                                birth = None
                                break
                            else:
                                print("{} is not a valid date, try again".format(birth))
                                birth = None
                    father_name = input("Enter the father name:").title()
                    father_name = father_name if father_name != '' else None
                    father_sba = input("Enter the father's sba:")
                    father_sba = father_sba if father_sba != '' else None
                    mother_name = input("Enter the mother's name:").title()
                    mother_name = mother_name if mother_name != '' else None
                    mother_sba = input("Enter the mother'sba:")
                    mother_sba = mother_sba if mother_sba != '' else None
                    print("{:5} {:10}".format("#", "Coat"))
                    print("_____ __________")
                    for num, coat in enumerate(sorted(coats, key=lambda coat: coat[2])):
                        print("{:5} {:10}".format(num, coat[2]))
                    valid = [str(num )for num in range(len(coats))]
                    valid.append("")
                    ans = Console.get_menu_choice("Enter the coat # or Enter for nothing", valid, "''")
                    if ans != "''":
                        coat_id = sorted(coats, key= lambda coat: coat[2])[int(ans)][0]
                        coat_id =int(coat_id) if coat_id != "''" else None
                    if sba == '':
                        res, Ok = handle_request(address,["ANCESTOR_CHECK", (tup[0][7],)])
                        return res
                    cont = Console.get_menu_choice("Confirm? (Y/N)", "YyNn", "y", True)
                    if cont == "y":
                        break
                args = (horse_name, birth, coat_id, father_name, father_sba, mother_name, mother_sba, sba, rp, tup[0][7])
                res, Ok = handle_request(address, ["UPDATE_ANCESTOR", args])
                return res
            else:
                return  "The Horse '{}'was not updated.".format(tup[0][0])

    def edit_ancestor(horse_row=None):
        if horse_row is None:
            horse = Console.get_string("Name of the horse to edit:")
            res, Ok = handle_request(address,["GET_HORSE",*horse])
        coat, OK = handle_request(address,["GET_COATS"])
        coats = coat[1]
        while True:
            horse_name = Console.get_string("Enter the horse name:", default=horse_row[0])
            sba = Console.get_string("Enter the SBA: ", default=horse_row[1])
            sba = sba if sba != "''" else None
            rp = Console.get_string("Enter the RP:", default=horse_row[2])
            rp = rp if rp != "''" else None
            while True:
                birth = Console.get_string("Enter the birth date as 'yyyy/mm/dd':", default=horse_row[5])
                try:
                    datetime.strptime(birth, "%Y/%m/%d")
                    break
                except ValueError as err:
                    if birth == '':
                        birth = None
                        break
                    else:
                        print("{} is not a valid date, try again".format(birth))
                        birth = None
            father_name = Console.get_string("Enter the father name:", default=horse_row[6])
            father_name = father_name if father_name != '' else None
            father_sba = Console.get_string("Enter the father's sba:", default=horse_row[11])
            father_sba = father_sba if father_sba != '' else None
            mother_name = Console.get_string("Enter the mother's name:", default=horse_row[7])
            mother_name = mother_name if mother_name != '' else None
            mother_sba = Console.get_string("Enter the mother'sba:", default=horse_row[12])
            mother_sba = mother_sba if mother_sba != '' else None
            print("\n{:5} {:10}".format("#", "Coat"))
            print("_____ __________")
            for num, coat in enumerate(sorted(coats, key=lambda coat: coat[2])):
                print("{:5} {:10}".format(num, coat[2]))
            valid = [str(num) for num in range(len(coats))]
            valid.append("")
            coat_id = Console.get_menu_choice("Enter the coat # or Enter for nothing", valid,  "''")
            if coat_id != "":
                coat_id = int(coat_id) if coat_id != "''" else None
            else:
                coat_id = None
            cont = Console.get_menu_choice("Confirm? (Y/N)", "YyNn", "y", True)
            if cont == "y":
                break
        args = (
            horse_name, birth, coat_id, father_name, father_sba, mother_name, mother_sba, sba,
            rp, horse_row[8])
        result, Ok = handle_request(address, ["UPDATE_ANCESTOR", args])
        if result:
            if result[1] >= 1:
                if sba is None:
                    chk, Ok = handle_request(address, ["ANCESTOR_CHECK", (horse_row[8])])
                    print("{} has been set as a non registered AACCPA horse", format(horse_name))
                    re_res, Ok = handle_request(address, ["UPDATE_ANCESTOR", (args)])
                    if re_res[1] >= 1:
                        return True
                    return False
                return True

    def edit_horse():
        pass

    def verify_duplicate(res, coats, action):
        message = """\nThe systems already has the record: id: {0[0]} 
                                      Name: {0[1]} sba: {0[2]} RP: {0[3]} born on: {0[4]} sex: {0[5]}
                                      coat: {0[6]} by: {0[7]} ({0[8]}) on {0[9]} ({0[10]}). \n
                                      Do you want to:
                                      \t(U)pdate all records to this one.
                                      \t(M)odify this record.
                                      \tM(o)dify '{1[0]} data'
                                      \t(T)ake no action.""".format(res[2],res[3])
        do = Console.get_menu_choice(message, "UuTtMmOo", "t", True)
        if do == "u":
            chk, Ok = handle_request(address, ["FIX_DUPLICATE", (res[3][9], res[2][0], action)])
            if chk:
                if action == 's':
                    print("{} stallion record were updated and {} record deleted".format(*chk[1]))
                print("{} mare and {} grandmare references were update. {} record was deleted ".format(*chk[1]))
            return True
        elif do == 'm':
            while True:
                horse_name = Console.get_string("Enter the horse name:", default=res[2][1])
                sba = Console.get_string("Enter the SBA: ", default=res[2][2])
                sba = sba if sba != "''" else None
                rp = Console.get_string("Enter the RP:", default=res[2][3])
                rp = rp if rp != "''" else None
                while True:
                    birth = Console.get_string("Enter the birth date as 'yyyy/mm/dd':", default=res[2][4])
                    try:
                        datetime.strptime(birth, "%Y/%m/%d")
                        break
                    except ValueError as err:
                        if birth == '':
                            birth = None
                            break
                        else:
                            print("{} is not a valid date, try again".format(birth))
                            birth = None
                father_name = Console.get_string("Enter the father name:", default=res[2][7]).title()
                father_name = father_name if father_name != '' else None
                father_sba = Console.get_string("Enter the father's sba:", default=res[2][8])
                father_sba = father_sba if father_sba != '' else None
                mother_name = Console.get_string("Enter the mother's name:", default=res[2][9]).title()
                mother_name = mother_name if mother_name != '' else None
                mother_sba = Console.get_string("Enter the mother'sba:", default=res[2][10])
                mother_sba = mother_sba if mother_sba != '' else None
                print("\n{:5} {:10}".format("#", "Coat"))
                print("_____ __________")
                for num, coat in enumerate(sorted(coats, key=lambda coat: coat[2])):
                    print("{:5} {:10}".format(num, coat[2]))
                valid = [str(num) for num in range(len(coats))]
                valid.append("")
                ans = Console.get_menu_choice("Enter the coat # or Enter for nothing", valid,"")
                if ans != "":
                    coat_id = int(coat_id) if coat_id != "''" else None
                else:
                    coat_id = None
                cont = Console.get_menu_choice("Confirm? (Y/N)", "YyNn", "y", True)
                if cont == "y":
                    break
            args = (
                horse_name, birth, coat_id, father_name, father_sba, mother_name, mother_sba, sba,
                rp, res[2][0])
            result, Ok = handle_request(address, ["UPDATE_ANCESTOR", args])
            if result:
                if result[1] >= 1:
                    if sba is None:
                        chk, Ok = handle_request(address, ["ANCESTOR_CHECK", (res[2][0])])
                        print("{} has been set as a non registered AACCPA horse",format(horse_name))
                    re_res, Ok = handle_request(address,["UPDATE_ANCESTOR", (res[3])])
                    if re_res[1] >= 1:
                        return True
            return False
        elif do == "o":
            while True:
                horse_name = Console.get_string("Enter the horse name:", default=res[3][0])
                sba = Console.get_string("Enter the SBA: ", default=res[3][7])
                sba = sba if sba != "''" else None
                rp = Console.get_string("Enter the RP:", default=res[3][8])
                rp = rp if rp != "''" else None
                while True:
                    birth = Console.get_string("Enter the birth date as 'yyyy/mm/dd':", default=res[3][1])
                    try:
                        datetime.strptime(birth, "%Y/%m/%d")
                        break
                    except ValueError as err:
                        if birth == '':
                            birth = None
                            break
                        else:
                            print("{} is not a valid date, try again".format(birth))
                            birth = None
                father_name = Console.get_string("Enter the father name:", default=res[3][3]).title()
                father_name = father_name if father_name != '' else None
                father_sba = Console.get_string("Enter the father's sba:", default=res[3][4])
                father_sba = father_sba if father_sba != '' else None
                mother_name = Console.get_string("Enter the mother's name:", default=res[3][5]).title()
                mother_name = mother_name if mother_name != '' else None
                mother_sba = Console.get_string("Enter the mother'sba:", default=res[3][6])
                mother_sba = mother_sba if mother_sba != '' else None
                print("\n{:5} {:10}".format("#", "Coat"))
                print("_____ __________")
                for num, coat in enumerate(sorted(coats, key=lambda coat: coat[2])):
                    print("{:5} {:10}".format(num, coat[2]))
                valid = [str(num) for num in range(len(coats))]
                valid.append("")
                ans = Console.get_menu_choice("Enter the coat # or Enter for nothing", valid,"")
                if ans != "":
                    coat_id = int(coat_id) if coat_id != "''" else None
                else:
                    coat_id = None
                cont = Console.get_menu_choice("Confirm? (Y/N)", "YyNn", "y", True)
                if cont == "y":
                    break
            args = (
                horse_name, birth, coat_id, father_name, father_sba, mother_name, mother_sba, sba,
                rp, res[3][9])
            result, Ok = handle_request(address, ["UPDATE_ANCESTOR", args])
            if result:
                if result[1] >= 1:
                    if sba is None:
                        chk, Ok = handle_request(address, ["ANCESTOR_CHECK", (res[2][0])])
                        print("{} has been set as a non registered AACCPA horse",format(horse_name))
                    re_res, Ok = handle_request(address,["UPDATE_ANCESTOR", (res[3])])
                    if re_res[1] >= 1:
                        return True
            return False



    def update_player_ancestor(cat, *tup):
        if cat == "m":
            message = "\nThe player mare '{0[0]}' foaled {0[1]} on '{0[2]}' SBA: {0[3]}."\
                                    "\nDo you want to: " \
                                    "\n\t(S)ave the data; \n\t(C)heck the (A)ACCPA; or " \
                                    "\n\t(C)ancel ".format(*tup)
        elif cat == "s":
            message = "\nThe player stallion '{0[0]}' born on {0[6]} sired '{0[1]}' on {0[2]} SBA:{0[4]}."\
                                    "\nDo you want to: " \
                                    "\n\t(S)ave the data; \n\t(C)heck the (A)ACCPA; or " \
                                    "(\n\t(C)ancel ".format(*tup)
        elif cat == "g":
            message = "\nThe player mare '{0[0]}' born on {0[1]} gradma '{0[2]}' on {0[3]}."\
                                    "\nDo you want to: " \
                                    "\n\t(S)ave the data; \n\tCheck the (A)ACCPA;" \
                                    "(\n\t(C)ancel ".format(*tup)
        act = Console.get_menu_choice(message, "CcsSaA", "c", True)
        if act == "c":
            return False, "Canceled"
        elif act == "a":
            res = check_aaccpa(tup)
        else:
            res = True
        if res:
            tup_check = tup[0][4:]
            result, data = handle_request(address, ['UPDATE_PLAYER_ANCESTOR', tup_check])
            return result

    def pull_ancestor_products(horse_id, sex_code):
        horse_list, Ok = handle_request(address, ["PULL_ANCESTOR_PRODUCTS", horse_id, sex_code])
        if not horse_list[0]:
            print("The production could´nt be obtained for {}".format(horse_list[1]))
            return
        print("\n{0[1]:35} {0[2]:7} {0[3]:12} {0[6]:20} {0[7]:9} {0[8]:12} {0[9]:20} {0[10]:5}".format(horse_list[1]))
        horse = ''
        for num, tup in enumerate(horse_list[2]):
            if tup[0]!= horse:
                message = "\n{}: {}'s high handicap performance progeny".format(horse_list[1][0], tup[0])
                print(message)
                horse = tup[0]
            print("{0[1]:35} {0[2]:7} {0[3]:12} {0[6]:20} {0[7]:9} {0[8]:12} {0[9]:20} {0[10]:5}".format(tup))

        return


    def check_ancestors(address):
        while True:
            ans = Console.get_menu_choice("(L)ist (V)erify (R)eturn", "LlVvRr", "r", True)
            if ans == "r":
                return
            elif ans == "l":
                while True:
                    sex_code = Console.get_menu_choice("(M)others (G)randmares (S)tallions (R)eturn", "MmGgSsRr",
                                              "r", True )
                    if sex_code == "r":
                        continue
                    horse_list, Ok = handle_request(address, ["LOAD_ANCESTORS", (sex_code,)])
                    print("\n{0:<4} {1[0]:<25} {1[1]:<8} {1[2]:<9} {1[3]:<7} {1[4]:<20} {1[5]:<15} "
                      "{1[6]:<25} {1[7]:<25}".format("#",horse_list[1]))
                    rows = ["R", "r",]
                    for num, tup in enumerate(horse_list[2]):
                        print("{0:<4} {1[0]:<25} {1[1]!r:<8} {1[2]!r:<9} {1[3]!r:<7} {1[4]!r:<20} {1[5]!r:15}"
                              " {1[6]!r:25} {1[7]!r:<25}".format(num, tup))
                        rows.append(str(num))
                    action = Console.get_menu_choice("(E)dit (P)rogeny (R)eturn", "EeRrPp", "r", True)
                    if action == "r":
                        continue
                    elif action == "e":
                        row = Console.get_menu_choice("Select the record (#) or (R)eturn", rows,
                                                      "r", True)
                        if row == "r":
                            break
                        tup = horse_list[2][int(row)]
                        print("\n{0[0]} SBA:{0[1]!r} RP:{0[2]!r} {0[3]!r} {0[4]!r} Born:{0[5]!r}"
                              " By:{0[6]!r} On:{0[7]!r}".format(tup))
                        edit_ancestor(horse_list[2][int(row)])
                        break
                    elif action == "p":
                        rows += ["A","a"]
                        row = Console.get_menu_choice("Select the record (#); (A)ll the records; or (R)eturn", rows,
                                                      "r", True)
                        if row == "r":
                            break
                        if row == "a":
                            pull_ancestor_products(row, sex_code)
                            continue
                        else:
                            tup = horse_list[2][int(row)]
                            print("\n{0[0]} SBA:{0[1]!r} RP:{0[2]!r} {0[3]!r} {0[4]!r} Born:{0[5]!r}"
                              " By:{0[6]!r} On:{0[7]!r}".format(tup))
                            pull_ancestor_products(tup[8], sex_code)
                            continue
            elif ans == "v":
                break

        while True:
            men = "(M)others (G)randmothers (S)tallions (R)eturn"
            val = frozenset("mMgGsSrR")
            action = Console.get_menu_choice(men, val, "r", True)
            menu = "Enter the file number (#); (A)ll to process continuously; or Enter to cancel"
            if action != "r":
                result, data = handle_request(address, ["PULL_ANCESTORS", action])
                ok, lst_col_horse, lst_in_horse, lst_to_check, lst_col_check = result
            if action == "r":
                return False, None, None, None, None
            elif action == "m":
                message_print_in_horse = "\n Tournament player mares that have foaled tournament players"
                message_print_to_check = "\nMares that have foaled tournament players"

            elif action == "g":
                message_print_in_horse = "\n Tournament player Mares that have foaled tournament players" \
                                         "producing mares -Grandmas"
                message_print_to_check = "\n Mares the have granmaded tournament players"
                sessage_ask = "The player grandma '{0[0]}' born on {0[1]} was grandma of '{0[2]}' on {0[3]}."
            elif action == "s":
                message_print_in_horse = "\n Tournament player stallions that have sired tournament players"
                message_ask = "The player colt '{0[0]}' born on {0[1]} sired '{0[2]}' on {0[3]}."
            checked_to_check = []
            while True:
                lst = [lt for lt in lst_in_horse if lt[8] not in checked_to_check]
                if len(lst) > 0:
                    print(message_print_in_horse)
                    print("{:<3} {:15} {:10} {:15} {:10} ".format("#",*lst_col_horse))
                    print("___ _______________ __________ _______________ __________ ")
                    for num, lt in enumerate(lst):
                        print("{:<3} {:15} {:10} {!r:15} {!r:10}".format(num, *lt))
                    print("\n")
                    valid = [str(num) for num in range(len(lst_in_horse))]
                    valid += ["a", ""]
                    act = Console.get_menu_choice(menu, valid, "''")
                    if act == "a":
                        for act, lt in enumerate(lst):
                            res = update_player_ancestor(action, lt)
                            if isinstance(res[1], Exception):
                                print(
                                    "\n{} could not be updated because of {}".format(lst[act][0], res[1]))
                                ans = Console.get_menu_choice("(C)ontinue or C(a)ncel?", "CcaA", "a", True)
                                if ans == "a":
                                    break
                                else:
                                    continue
                            if not res[0]:
                                print("Update of {} was {}".format(lt[0], res[1]))
                                continue

                            checked_to_check.append(lt[8])
                    elif act == "''":
                        break
                    else:
                        res = update_player_ancestor(action, lst[int(act)])
                        if isinstance(res[1],Exception):
                            print("\n{} could not be updated because of {}".format(lst_in_horse[int(act)][0],res[1]))
                            ans = Console.get_menu_choice("(C)ontinue or C(a)ncel?", "CcaA","a",True)
                            if ans == "a":
                                break
                            else:
                                continue
                        if not res[0]:
                            print("Update of {} was {}".format(lst[int(act)][0], res[1]))
                            continue
                        if res[0] is None:
                            print("Update of {} was {}".format(lst[int(act)], res[1][0]))
                            break
                        checked_to_check.append(lst[int(act)][8])
                else:
                    break
            if len(lst_to_check) > 0 :
                coat, Ok = handle_request(address,["GET_COATS"])
                coats = coat[1]
                sex, Ok = handle_request(address,["GET_SEXES"])
                sexes = sex[1]
            checked_to_check = []
            while True:
                lst = [lst for lst in lst_to_check if lst[7] not in checked_to_check]
                if len(lst) > 0:

                    print("\n{:<3} {:22} {:31} {:10} {:15} {:20} {:20}".format('#', *lst_col_check[:8]))
                    print("___ ______________________ _______________________________ "
                          "__________ _______________ ____________________"
                          "____________________")
                    for num, tup in enumerate(lst):
                        print("{:<3} {:22} {:31} {!r:10} {:15} {:20} {:20}".format(num, *tup[:8]))
                    print("\n")
                    valid = [str(num) for num in range(len(lst))]
                    valid += ["a", ""]
                    act = Console.get_menu_choice(menu, valid,"''")
                    if act == "a":
                        for act, tup in enumerate(lst):
                            res = update_ancestor(action,coat[1], tup)
                            if isinstance(res[1], Exception):
                                if isinstance(res[1], IntegrityError):
                                    result = verify_duplicate(res, coats, action)
                                message = "\n'{}' could not be updated because of '{}'" \
                                          "(C)ontinue or C(a)ncel?".format(lst_to_check[int(act)][0], res[1])
                                ans = Console.get_menu_choice(message, "CcaA", "a", True)
                                if ans == "a":
                                    return
                                else:
                                    continue
                            if res[0] is None:
                                print("Update of {} was {}\n".format(lst[int(act)][0], res[1]))
                                break
                            if not res[0]:
                                print("{} was {}\n".format(lst[int(act)][0], res[1]))
                            checked_to_check.append(lst[int(act)][7])

                    elif act == "''":
                        break
                    else:
                        res = update_ancestor(action, coat[1], lst[int(act)])
                        if isinstance(res[1], Exception):
                            if isinstance(res[1],IntegrityError):
                                result = verify_duplicate(res, coats, action)
                            message = "\n'{}' could not be updated because of '{}'" \
                                  "(C)ontinue or C(a)ncel?".format(lst_to_check[int(act)][0], res[1])
                            ans = Console.get_menu_choice(message, "CcaA", "a", True)
                            if ans == "a":
                                return
                            else:
                                continue
                        if res[0] is None:
                            print("Update of {} was {}\n".format(lst[int(act)][0], res[1]))
                            break
                        if not res[0]:
                            print("{} was {}\n".format(lst[int(act)][0], res[1]))
                        checked_to_check.append(lst[int(act)][7])

                else:
                    break

    def query_horse(Horse_name):
        pass


    def query_player(player_name):
        pass

    def query_tournament(tournament_name):
        pass
    def return_main():
        return None

    address = items[2]
    call = dict(a=check_ancestors, h=query_horse, p=query_player, t=query_tournament,
                r=return_main)
    valid = "aAhHpPrR"
    menu = ("(A)ncestors (H)orses  (P)layers (T)ournaments (B)reeders (O)wners (R)eturn")
    action = Console.get_menu_choice(menu, valid, "r",True)
    result = call[action](address)
    return result

class SocketManager:

    def __init__(self, address):
        self.address = address

    def __enter__(self):
        self.sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        self.sock.connect(self.address)
        return self.sock

    def __exit__(self,*ignore):
        self.sock.close()


main()
